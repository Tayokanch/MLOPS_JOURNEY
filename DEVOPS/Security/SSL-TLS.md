*Encryption*
- This is an Important method used in encrypting data before sending them between 2 different machines e.g (client and server) over the network securely

- To Encrypt a data we need a **key** which is a string of characters and numbers. 

- We use Encrption Algorithm  e.g `AES256` which takes the `data` and `key` to form an `Encrypted data` in form of a string 
  
*There are 2 Types of Encrption*

1. *Symmetric Encryption*
   - This is a process where an `Encrypted Data/Information` is sent over to the network/server with the encyption `key`. The problem with this is that HACKER could steal the `Encrypted Data/Information` and `key` and use the same `key` to `Decrpyt the Data/Information` and have our Data/Information in a readable format. This is the problem `Asymmetic Encryption` solves. 

2. * Asymmetric Encryption*
- In `Asymmetric Encryption` we have 2 keys, the `public key` and the `private key`. We can use either of the 2 keys to encrpt. However, if you use one to `encrypt`, we use the other to `decrypt` e.g if we use `public key` to encrypt, we would use `private key` to decrypt  and if we use `private key` to encrypt, we would use `public key` to decrypt.

*How To Utilize Asymmetric Encryption To Send Data Over the Network/Server in A Secure Manner*

- The server we are sending Data/Information to would have a `public` and `private` key. The `public key` is public and is accessible to anybody in the world and the `private key` is only know to the server itself.

*Process of Sending Data from Client to Server*

- The `client` would first inform the `server` that I want to send a data to you, and this would establish a `HANDSHAKE` btw them.

- The `Server` would acknolwedge it and send the `client` a `Public Key`

- The client would then creates a random `symmetric key` (called the pre-master secret).
  
- Now the client has the `Public Key` from the server and the also a `symmetric key`

- Then Encrypt the `symmetric key` with the `public key` from the server

- Then send the `Ecrypted symmetric key` back to the server

- The `server` would then `decrypt` the `Ecrypted symmetric key`, and then the `symmetric key` would be available on both client and server.

- After the `symmetric Key` is available on both client and server, this forms a connection btw them. Any `Data` coming from the client would be encrypted by the `symmetric Key` available on the client and the Server would also be able to `decrypt` the `Data` with its `private key`

*How Make Sure The Public Key is Coming from The right source*

- Making sure `Public Key` comes from the right source is where `Certificate Authority` comes in.
- A  `Certificate Authority` is a third party entity that is trusted by the Browsers e.g Chrome, Mozzila etc
- A `Certificate Authority` also comes with a `Public key` and a `Private Key`. The `Public Key` is known to the world while the `Private Key` is only know to the `Certificate Authority`


# Process of Sending Data from Client to Server Using A Certificate Authority

- The `client` would first inform the `server` that I want to send a data to you, and this would establish a `HANDSHAKE` btw them.
  
- Then the `Server` would reply with a `Certificate`. This certificate was already created and signed by a trusted `Certificate Authority (CA)`.

- **A certificate** is a text file that contains information and is grouped into three different parts:
  1. The first information would be who the certificate was issued to e.g `facebook.com server`, and who issued the certificate i.e The `Certificate Authority Company` e.g `DigiCert`.
   
  2. The second information is the `server public key` e.g `facebook.com server public key` which was sent to the `CA` when the certificate was requested.
   
  3. The third information is the `digital signature` which is generated by the `Certificate Authority`. The CA creates this signature using its `private key` to sign a hash of the certificate contents (including the server public key).

- The `CA` would then send the signed `Certificate` to the server with the information listed above.
  
- The `Server` would then send the `Certificate` to the `client`, which contains the information listed above, including the `server public key` and the `CA digital signature`.

- The `client` would then **verify** the `CA digital signature` by using the `CA public key` (which is already stored in the client’s trusted root store). If the signature is valid, the client can trust that the `server public key` in the certificate is authentic.



<**openssl genrsa -out security_name.key 2048**> : This is used for generating `private` and `public key` on the `remote server`. The `public key` goes into a Certificate Signing Request (CSR), which you send to the Certificate Authority (CA) to get a certificate.

<**openssl rsa -in security_name.key -pubout> mybank.pem**> : Here we are extracting a Public key from the private key generated and redirecting/saving it to a file called **mybank.pem**

<**openssl req -new -key security_name.key -out Security-name.csr -subj "/C=US/ST=CA/O=MyBank/CN=mybank.com"**>: Create a `Certificate Signing Request (CSR)`. The output would be Security-name.csr which is the file to send to the `CA`

- <**You send my-bank.csr to a CA.**>: Send the `Certificate Signing Request file` to any `CA` of Choice 

- <Stage 4 — Server uses the certificate for TLS>: Then use the `Certificate` for `Transport Layer Security` TLS

# NOTE: Naming Convension
- *.crt, *.pem : These are public keys naming convension
- *.key , *-key.pem: These are the private keys naming conve